package riw;


import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import javax.swing.GroupLayout;
import javax.swing.JButton;
import javax.swing.JTextField;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Nassim Guergouri
 */
public class Requete extends javax.swing.JFrame {

    /**
     * Creates new form Requete
     */
    ArrayList<TokenElement> Token;
    Resultat ru = new Resultat();
    ArrayList fichier_fina;
    String[][] files_name;
    public Requete(ArrayList<TokenElement> T,String[][] files) {
        initComponents();
        Token = T;
        files_name = files;
    }

    public JButton getExecuter() {
        return executer;
    }

    public void setExecuter(JButton executer) {
        this.executer = executer;
    }

    public JTextField getjTextField1() {
        return jTextField1;
    }

    public void setjTextField1(JTextField jTextField1) {
        this.jTextField1 = jTextField1;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jTextField1 = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        executer = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setLocation(new java.awt.Point(330, 150));

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 16)); // NOI18N
        jLabel1.setText("Requete");

        executer.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        executer.setText("Exécuter");
        executer.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                executerMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jTextField1)
                .addContainerGap())
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(154, Short.MAX_VALUE)
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(139, 139, 139))
            .addGroup(layout.createSequentialGroup()
                .addGap(148, 148, 148)
                .addComponent(executer)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(21, 21, 21)
                .addComponent(jLabel1)
                .addGap(18, 18, 18)
                .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(executer)
                .addContainerGap(31, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void executerMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_executerMouseClicked
        
        
        // Champ pour récupérer la requete
        String requete = getjTextField1().getText();
        // Séparés les mots de la requete par "OR"
        ArrayList req = new ArrayList<String>();
        req.addAll(Arrays.asList(requete.split(" or ")));
        
        
        ArrayList nom_fichier1 = new ArrayList<String>();
        ArrayList suggestion = new ArrayList<String>();
        ArrayList result_pour = new ArrayList<String>();
        fichier_fina =  new ArrayList<String>();
        int threshold = 2;
        for (Object req1 : req) {
            // Tester s'il le mot contient la clause "AND"
            if(req1.toString().contains("and")){
                // Séparé les mots par le mot "AND"
                String[] and_word = req1.toString().split(" and ");
                boolean first = true;
                // Parcourir tout les mots 
                for (String and_word1 : and_word) {
                    boolean trouver = false;
                    and_word1 = and_word1.toString().replaceAll("\\s+","");
                    if(first){
                        
                        for (TokenElement Token1 : Token) {
                            if(Token1.getValue().equalsIgnoreCase(and_word1)){
                                trouver=true;
                                result_pour.add(Token1.getValue());
                                DocElement temp = Token1.getFirst();
                                while(temp != null){
                                    nom_fichier1.add(temp.getValue());
                                    temp = temp.getNext();
                                }
                            }
                            else 
                            if(distance(Token1.getValue(),and_word1)<=threshold)
                            if(soundex(Token1.getValue()).equalsIgnoreCase(soundex(and_word1))){
                                
                                result_pour.add(Token1.getValue());
                                DocElement temp = Token1.getFirst();
                                while(temp != null){
                                    nom_fichier1.add(temp.getValue());
                                    temp = temp.getNext();
                                }
                            }
                        }
                        first = false;
                    }
                    else{
                        // Commparer les documents du 2 termer et faire l'intersection 
                        // avec les documents déja insérés
                        
                        ArrayList temp_w = new ArrayList(nom_fichier1);
                        nom_fichier1 = new ArrayList<String>();
                        for (TokenElement Token1 : Token) {
                            if(Token1.getValue().equalsIgnoreCase(and_word1)){
                                result_pour.add(Token1.getValue());
                                trouver=true;
                                DocElement temp = Token1.getFirst();
                                while(temp != null){
                                    for(Object name:temp_w){
                                        if(name.toString().equalsIgnoreCase(temp.getValue()))
                                            if(!existe_doc(nom_fichier1,name.toString()))
                                            {nom_fichier1.add(temp.getValue());
                                            
                                            }
                                    }
                                    temp = temp.getNext();
                                }
                            }else 
                            if(distance(Token1.getValue(),and_word1)<=threshold)
                            if(soundex(Token1.getValue()).equalsIgnoreCase(soundex(and_word1))){
                                result_pour.add(Token1.getValue());
                                DocElement temp = Token1.getFirst();
                                while(temp != null){
                                    for(Object name:temp_w){
                                        if(name.toString().equalsIgnoreCase(temp.getValue()))
                                            if(!existe_doc(nom_fichier1,name.toString()))
                                            {nom_fichier1.add(temp.getValue());
                                            
                                            }
                                    }
                                    temp = temp.getNext();
                                }
                            }   
                        }
                    }
                    if(!trouver){
                        System.out.println("yess");
                       for (TokenElement Token1 : Token) {
                            
                            if(distance(Token1.getValue(),and_word1)<=threshold)
                            if(soundex(Token1.getValue()).equalsIgnoreCase(soundex(and_word1))){
                                
                                System.out.println(Token1.getValue());
                                suggestion.add(Token1.getValue());
                            }   
                        } 
                    }
                }
                if(fichier_fina.size()==0){
                    fichier_fina.addAll(nom_fichier1);
                }else{
                    for (Iterator it = nom_fichier1.iterator(); it.hasNext();) {
                            Object temp1 = it.next();
                            if(!existe_doc(fichier_fina,temp1.toString()))
                                    fichier_fina.add(temp1.toString());
                        
                    } 
               }
            }else{
                boolean trouver1=false;
                String terme = req1.toString();
                ArrayList nom_fichier = new ArrayList<String>();
                for (TokenElement Token1 : Token) {
                    if(Token1.getValue().equalsIgnoreCase(terme)){
                        trouver1 = true;
                        result_pour.add(Token1.getValue());
                        DocElement temp = Token1.getFirst();
                        while(temp != null){
                            nom_fichier.add(temp.getValue());
                            temp = temp.getNext();
                        }
                    }else 
                        if(distance(Token1.getValue(),terme)<=threshold)
                        if(soundex(Token1.getValue()).equalsIgnoreCase(soundex(terme))){
                        result_pour.add(Token1.getValue());
                        DocElement temp = Token1.getFirst();
                        while(temp != null){
                            nom_fichier.add(temp.getValue());
                            temp = temp.getNext();
                        }
                    }   
                }
                if(!trouver1){
                       for (TokenElement Token1 : Token) {
                            if(distance(Token1.getValue(),terme)<=threshold)
                            if(soundex(Token1.getValue()).equalsIgnoreCase(soundex(terme))){
                                suggestion.add(Token1.getValue());
                            }   
                        } 
                    }
                
                if(fichier_fina.size()==0){
                    fichier_fina.addAll(nom_fichier);
                }else{
                    for (Iterator it = nom_fichier.iterator(); it.hasNext();) {
                            Object temp1 = it.next();
                            if(!existe_doc(fichier_fina,temp1.toString()))
                                    fichier_fina.add(temp1.toString());
                        
                    } 
               }
            }
        }
    
       
        Collections.sort(fichier_fina);
        ArrayList temp = new ArrayList(fichier_fina);
        fichier_fina = new ArrayList<String>();
        for (Iterator it = temp.iterator(); it.hasNext();) {
            Object temp1 = it.next();
            for (String[] files_name1 : files_name) {
                if(temp1.toString().equalsIgnoreCase(files_name1[0])){
                    fichier_fina.add(files_name1[1]);
                }
            }
        }
        for (Object nom_fich : fichier_fina) {
            System.out.println(nom_fich.toString());
        }
       
       ru.setVisible(true);
       int size=1;
       if(!fichier_fina.isEmpty())
           size = fichier_fina.size();
       else
           size = 1;
       
      javax.swing.JLabel[] jlabel= new javax.swing.JLabel[size+2];
      if(!suggestion.isEmpty()){
        jlabel[0] = new javax.swing.JLabel();
        String suggest ="Essayer avec : ";
          
          for (Object sugg : suggestion) {
            suggest = suggest+sugg.toString()+",";
        }
          jlabel[0].setText(suggest);
       jlabel[0].setFont(new java.awt.Font("Tahoma", 1, 12)); 
       String result = "Résulat pour :";
       for (Object res : result_pour) {
            result = result+res.toString()+",";
        }
          jlabel[1] = new javax.swing.JLabel();  
          jlabel[1].setText(result);
       jlabel[1].setFont(new java.awt.Font("Tahoma", 1, 12));
       for(int i=2; i<fichier_fina.size()+2;i++){
          jlabel[i] = new javax.swing.JLabel();
          String name = fichier_fina.get(i-2).toString();
       jlabel[i].setText((i-1)+"- "+fichier_fina.get(i-2).toString());
       jlabel[i].setFont(new java.awt.Font("Tahoma", 1, 13));
       jlabel[i].addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
               String n = name;
               Resultat r= ru;
                jLabel1MouseClicked(evt,n,r);
            }
        });
      }
      }else
      if(fichier_fina.isEmpty()){
          jlabel[0] = new javax.swing.JLabel();
          jlabel[0].setText("Non Résultats");
       jlabel[0].setFont(new java.awt.Font("Tahoma", 1, 15));
       ru.getjTextArea1().setText("Vide");
      }else
      {
      for(int i=0; i<fichier_fina.size();i++){
          jlabel[i] = new javax.swing.JLabel();
          String name = fichier_fina.get(i).toString();
       jlabel[i].setText((i+1)+"- "+fichier_fina.get(i).toString());
       jlabel[i].setFont(new java.awt.Font("Tahoma", 1, 15));
       jlabel[i].addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
               String n = name;
               Resultat r= ru;
                jLabel1MouseClicked(evt,n,r);
            }
        });
      }}
       javax.swing.GroupLayout layout = new javax.swing.GroupLayout(ru.getContentPane());
        ru.getContentPane().setLayout(layout);
        layout.setAutoCreateGaps(true);
layout.setAutoCreateContainerGaps(true);
        
      GroupLayout.ParallelGroup groupe = layout.createParallelGroup(GroupLayout.Alignment.LEADING);
        for(int i=0; i<size+2;i++){
            
           
            groupe.addComponent(jlabel[i], javax.swing.GroupLayout.PREFERRED_SIZE, 400, javax.swing.GroupLayout.PREFERRED_SIZE);
                
        
       }
        
        layout.setHorizontalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup()
        .addGap(40, 40, 40).addGroup(groupe).addContainerGap(355, Short.MAX_VALUE)));
       
       
        GroupLayout.SequentialGroup groupe1 = layout.createSequentialGroup().addGap(40, 40, 40);
         for(int i=0; i<size+2;i++){
        
                groupe1.addComponent(jlabel[i], javax.swing.GroupLayout.PREFERRED_SIZE, 15, javax.swing.GroupLayout.PREFERRED_SIZE);
                groupe1.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED);
                }
         groupe1.addContainerGap(317, Short.MAX_VALUE);
         layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(groupe1));
    }//GEN-LAST:event_executerMouseClicked
public static String soundex(String s) { 
        char[] x = s.toUpperCase().toCharArray();
        char firstLetter = x[0];

        // convert letters to numeric code
        for (int i = 0; i < x.length; i++) {
            switch (x[i]) {

                case 'B':
                case 'P':
                    x[i] = '1';
                    break;

                case 'C':
                case 'K':
                case 'Q':
                    x[i] = '2';
                    break;

                case 'D':
                case 'T':
                    x[i] = '3';
                    break;

                case 'L':
                    x[i] = '4';
                    break;

                case 'M':
                case 'N':
                    x[i] = '5';
                    break;

                case 'R':
                    x[i] = '6';
                    break;
                    
                case 'G':
                case 'J':
                    x[i] = '7';
                    break;
                    
                case 'X':
                case 'Z':
                case 'S':    
                    x[i] = '8';
                    break;
                    
                case 'F':
                case 'V':
                    x[i] = '9';
                    break;

                default:
                    x[i] = '0';
                    break;
            }
        }

        // remove duplicates
        String output = "" + firstLetter;
        for (int i = 1; i < x.length; i++)
            if (x[i] != x[i-1] && x[i] != '0')
                output += x[i];

        // pad with 0's or truncate
        output = output + "0000";
        return output.substring(0, 4);
    }
private static int minimum(int a, int b, int c) {                            
        return Math.min(Math.min(a, b), c);                                      
    } 
// Fonction Distance                                                                             
    public static int distance(CharSequence lhs, CharSequence rhs) {      
        int[][] distance = new int[lhs.length() + 1][rhs.length() + 1];        
                                                                                 
        for (int i = 0; i <= lhs.length(); i++)                                 
            distance[i][0] = i;                                                  
        for (int j = 1; j <= rhs.length(); j++)                                 
            distance[0][j] = j;                                                  
                                                                                 
        for (int i = 1; i <= lhs.length(); i++)                                 
            for (int j = 1; j <= rhs.length(); j++)                             
                distance[i][j] = minimum(                                        
                        distance[i - 1][j] + 1,                                  
                        distance[i][j - 1] + 1,                                  
                        distance[i - 1][j - 1] + ((lhs.charAt(i - 1) == rhs.charAt(j - 1)) ? 0 : 1));
                                                                                 
        return distance[lhs.length()][rhs.length()];                           
    } 
    
    public boolean existe_doc(ArrayList<String> fichier,String nom){
        for(String f:fichier){
            if(f.equalsIgnoreCase(nom))
                return true;
        }
        return false;
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Requete.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Requete.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Requete.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Requete.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
               
            }
        });
    }
private void jLabel1MouseClicked(java.awt.event.MouseEvent evt,String r,Resultat rl) {                                     
        // TODO add your handling code here:
        String FILENAME = "E:\\Corpus\\"+r+".txt";
        
        rl.getjTextArea1().setText("");
        try (BufferedReader br = new BufferedReader(new FileReader(FILENAME))) {

			String sCurrentLine;

			while ((sCurrentLine = br.readLine()) != null) {
				rl.getjTextArea1().append(sCurrentLine+"\n");
			}

		} catch (IOException e) {
			e.printStackTrace();
		}
        
        
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton executer;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JTextField jTextField1;
    // End of variables declaration//GEN-END:variables
}
